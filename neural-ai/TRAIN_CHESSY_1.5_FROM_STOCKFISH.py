"""
TRAIN CHESSY 1.5 FROM STOCKFISH DATA
Train neural network using positions generated by Stockfish vs Stockfish
"""

import json
import numpy as np
import tensorflow as tf
from tensorflow import keras
import os
from datetime import datetime

# Configuration
DATA_PATH = "training_data/stockfish_positions.json"
MODEL_PATH = "models/chessy_1.5_stockfish_model.h5"
EPOCHS = 50
BATCH_SIZE = 64
VALIDATION_SPLIT = 0.2

class ChessyTrainer:
    """Train Chessy neural network from Stockfish data"""
    
    def __init__(self):
        self.model = None
        self.training_data = None
        self.history = None
    
    def load_data(self):
        """Load training data from JSON"""
        print(f"ğŸ“‚ Loading data from {DATA_PATH}...")
        
        if not os.path.exists(DATA_PATH):
            print(f"âŒ Data file not found: {DATA_PATH}")
            print("   Run GENERATE_TRAINING_DATA_STOCKFISH.py first!")
            return False
        
        with open(DATA_PATH, 'r') as f:
            dataset = json.load(f)
        
        self.training_data = dataset
        
        print(f"âœ… Loaded {len(dataset['positions'])} positions")
        print(f"   From {dataset['statistics']['total_games']} games")
        
        return True
    
    def build_model(self):
        """Build neural network architecture"""
        print("\nğŸ—ï¸ Building neural network...")
        
        model = keras.Sequential([
            # Input layer: 768 features (64 squares * 12 piece types)
            keras.layers.Dense(512, activation='relu', input_shape=(768,)),
            keras.layers.BatchNormalization(),
            keras.layers.Dropout(0.3),
            
            # Hidden layers
            keras.layers.Dense(256, activation='relu'),
            keras.layers.BatchNormalization(),
            keras.layers.Dropout(0.3),
            
            keras.layers.Dense(128, activation='relu'),
            keras.layers.BatchNormalization(),
            keras.layers.Dropout(0.2),
            
            keras.layers.Dense(64, activation='relu'),
            keras.layers.Dropout(0.2),
            
            # Output layer: position evaluation (-1 to 1)
            keras.layers.Dense(1, activation='tanh')
        ])
        
        model.compile(
            optimizer=keras.optimizers.Adam(learning_rate=0.001),
            loss='mse',
            metrics=['mae']
        )
        
        self.model = model
        
        print("âœ… Model built")
        print(f"   Total parameters: {model.count_params():,}")
        
        return model
    
    def prepare_training_data(self):
        """Prepare X and y for training"""
        print("\nğŸ“Š Preparing training data...")
        
        positions = self.training_data['positions']
        
        # Extract features and evaluations
        X = np.array([pos['features'] for pos in positions])
        y = np.array([pos['evaluation']['normalized'] for pos in positions])
        
        print(f"âœ… Data prepared")
        print(f"   X shape: {X.shape}")
        print(f"   y shape: {y.shape}")
        print(f"   y range: [{y.min():.3f}, {y.max():.3f}]")
        
        return X, y
    
    def train(self):
        """Train the model"""
        print("\nğŸ§  Training neural network...")
        print(f"   Epochs: {EPOCHS}")
        print(f"   Batch size: {BATCH_SIZE}")
        print(f"   Validation split: {VALIDATION_SPLIT * 100}%")
        print("-"*70)
        
        X, y = self.prepare_training_data()
        
        # Callbacks
        callbacks = [
            keras.callbacks.EarlyStopping(
                monitor='val_loss',
                patience=10,
                restore_best_weights=True
            ),
            keras.callbacks.ReduceLROnPlateau(
                monitor='val_loss',
                factor=0.5,
                patience=5,
                min_lr=0.00001
            )
        ]
        
        # Train
        self.history = self.model.fit(
            X, y,
            epochs=EPOCHS,
            batch_size=BATCH_SIZE,
            validation_split=VALIDATION_SPLIT,
            callbacks=callbacks,
            verbose=1
        )
        
        print("\nâœ… Training complete!")
    
    def save_model(self):
        """Save trained model"""
        os.makedirs(os.path.dirname(MODEL_PATH), exist_ok=True)
        self.model.save(MODEL_PATH)
        print(f"\nğŸ’¾ Model saved to {MODEL_PATH}")
    
    def print_summary(self):
        """Print training summary"""
        print("\n" + "="*70)
        print("ğŸ“Š TRAINING SUMMARY")
        print("="*70)
        
        if self.history:
            final_loss = self.history.history['loss'][-1]
            final_val_loss = self.history.history['val_loss'][-1]
            final_mae = self.history.history['mae'][-1]
            final_val_mae = self.history.history['val_mae'][-1]
            
            print(f"\nğŸ“ˆ Final Metrics:")
            print(f"   Training Loss: {final_loss:.4f}")
            print(f"   Validation Loss: {final_val_loss:.4f}")
            print(f"   Training MAE: {final_mae:.4f}")
            print(f"   Validation MAE: {final_val_mae:.4f}")
            
            # Check for overfitting
            if final_val_loss > final_loss * 1.5:
                print(f"\nâš ï¸ Warning: Possible overfitting detected")
                print(f"   Val loss is {final_val_loss/final_loss:.2f}x training loss")
            else:
                print(f"\nâœ… Good generalization")
        
        print("\n" + "="*70)


def main():
    """Main training pipeline"""
    print("="*70)
    print("ğŸš€ CHESSY 1.5 - TRAINING FROM STOCKFISH DATA")
    print("="*70)
    
    trainer = ChessyTrainer()
    
    # Load data
    if not trainer.load_data():
        return
    
    # Build model
    trainer.build_model()
    
    # Train
    trainer.train()
    
    # Save
    trainer.save_model()
    
    # Summary
    trainer.print_summary()
    
    print("\nâœ… Training pipeline complete!")
    print(f"ğŸ“ Model saved to: {MODEL_PATH}")
    print(f"\nğŸ’¡ Next step: Test the model")
    print(f"   python TRAIN_CHESSY_1.5_SELF_PLAY.py")


if __name__ == "__main__":
    main()
